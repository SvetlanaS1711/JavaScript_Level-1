//'use strict';

/*
2. Не выполняя кода, ответить, что выведет браузер и почему:
*/

/*
if (!("a" in window)) { // Если window не содержит a, присвоить ей значение 1
    var a = 1;
}
alert(a); // window is not defined
*/

/*
1) Все глобальные переменные являются свойствами window. Запись var a = 1 эквивалентна записи window.a = 1. (Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.)
2) Все объявления переменных поднимаются в верхнюю часть области.
alert("a" in window);
var a;
Будет «истина», даже если объявление переменной происходит после вызова. Это связано с тем, что JavaScript сначала просматривает объявления переменных и перемещает их наверх. Фактически выполняется следующий код:
var a;
alert("a" in window);
3) Объявления переменных поднимаются, а инициализации переменных - нет. Эта строка является одновременно объявлением и инициализацией:
var a;    //declaration
a = 1;    //initialization
Когда JavaScript сталкивеются с комбинацией объявления и инициализации, он выполняет это разделение автоматически, чтобы объявление можно было поднять. Почему не запускается инициализация? Потому что это может повлиять на значение переменной во время выполнения кода и привести к неожиданным результатам.
4) Фактически исходный код можно привести к виду:

На стадии подготовки к выполнению, из var a создается window.a:

var a;                      // //window={a:undefined}
if (!("a" in window)) {     // в if видно что window.a уже есть
    a = 1;
}
alert(a);

Сначала объявляется переменная a, а затем оператор if говорит: «Если a не объявлен, инициализируйте a, чтобы он имел значение 1.» Это условие не может быть истинным, поэтому для переменной a остается значение по умолчанию undefined.
*/



/*
var b = function a(x) {
    x && a(--x);
};
alert(a); // a is not defined (а здесь undefined (если выше не определили))
*/


/*
1) Объявления переменных поднимаются наверх. Объявления функции также поднимаются наверх. Все объявления функций поднимаются в верхнюю часть области  вместе с объявлениями переменных (Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем — на предмет объявления переменных var. Каждое такое объявление добавляется в window.
). Объявление функции выглядит так:
function functionName(arg1, arg2){
    //function body
}
Объявления функций переопределяют объявления переменных, но не инициализации переменных. Чтобы понять это, рассмотрим следующие
function value(){
    return 1;
}
var value;
alert(typeof value);    //"function"
Значение переменной превращается в функцию, даже если объявление переменной появляется после объявления функции. В этой ситуации приоритет отдается объявлению функции. Однако добавьте инициализацию переменной, получите другой результат:
function value(){
    return 1;
}
var value = 1;
alert(typeof value);    //"number"
Теперь значение переменной установлено на 1. Инициализация переменной отменяет объявление функции.
2) Вернемся к коду, функция на самом деле является выражением функции, несмотря на название. Именованные выражения функций не считаются объявлениями функций и, следовательно, не переопределяются объявлениями переменных. Переменная, содержащая выражение функции, - это b, а имя выражения функции - a. Браузеры обрабатывают это иначе. Internet Explorer рассматривает его как объявление функции, поэтому он переопределяется инициализацией переменной, что означает, что вызов (-- x) вызывает ошибку. Все остальные браузеры разрешают вызов (-- x) внутри функции, в то время как a по-прежнему является числом вне функции. По сути, вызов b (2) в Internet Explorer вызывает ошибку JavaScript, но в других случаях возвращает значение undefined.
var a,
    b = function(x) {
        x && b(--x);
    };
alert(a);
*/



/*
function a(x) {
    return x * 2;
}
var a;
alert(a); // [Function: a] var не переинициализирует переменную.
*/

/*
Объявления функций важнее объявлений переменных, если не выполняется инициализация. Здесь нет инициализации, поэтому отображается исходный код функции.
*/


/*
function b(x, y, a) {
    arguments[2] = 10;   // меняет переменную
    alert(a);         // 10 a и arguments[2] — это ссылка на одно и то же значение. Иначе попадаем на память.
}
b(1, 2, 3);
*/



/*
function a() {
    alert(this);
}
a.call(null);   // this в глобальной области указывает на window. Вызов call() у функции с параметром null равнозначно вызову call() без аргументов. А без аргументов вызываемая функция не относится ни к какому объекту (или относится к «объекту по умолчанию» — window).
*/

/*
1) Метод вызывается для объекта, это указывает на объект, на котором находится метод. Пример:
var object = {
    method: function() {
        alert(this === object);    //true
    }
}
object.method();
В этом коде это заканчивается указанием на объект при вызове object.method (). В глобальной области это эквивалентно окну (в браузерах, в средах, отличных от браузера, это эквивалент глобального объекта), поэтому это также равно окну внутри функции, которая не является свойством объекта. Пример:
function method() {
    alert(this === window);    //true
}
method();
Заканчивается указанием на глобальный объект window.

2) Метод call () выполняет функцию, как если бы это был метод другого объекта. Первый аргумент становится this внутри метода, а каждый последующий аргумент передается в качестве аргумента функции. Учтите следующее:
function method() {
    alert(this === window);
}
method();    //true
method.call(document);   //false
(Если thisArg имеет значение null или undefined, вызываемой функции передается глобальный объект как значение this. В противном случае вызываемой функции передается ToObject (thisArg) как значение this.)
3) Поэтому всякий раз, когда null передается в call () (или apply ()), по умолчанию используется глобальный объект, которым является window. Учитывая это, пример кода можно переписать более понятным способом как:
function a() {
    alert(this);
}
a.call(window);
*/